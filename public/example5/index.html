<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="/normalize.css">
    <link rel="stylesheet" href="/hljs.min.css">
    <link rel="stylesheet" href="/default.css">
    <link rel="stylesheet" href="/styles/atom-one-light.css">
    <script src="/highlight.pack.js"></script>
    <script src="underscore_debounce.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <title>Async Example</title>
</head>

<body>
    <article class="docs">
        <section>
            <header>
                <h1>Subtle Animation Bugs</h1>
                <p>The following example demonstrates a more realistic example. Rather than a large bug that causes massive scroll jank, we have a minor issue that is sapping performance in a non-obvious way. If we continue to add logic to this page we are likely going to see a compounding decrease in performance.</p>
            </header>
            <div class="bold-checkbox">                
                <input id="waster" type="checkbox" value="waste" />
                <label>Enable wasteful call</label>
            </div>
            <div id="scrollDiv" style="overflow:auto;max-height: 200px;border: 1px solid #ccc;">
                <div id="colorBox" class="long flexBox">
                    
                </div>
                <style id="batchBlock" type="text/css"></style>
            </div>
        </section>

        <section>
            <h1>Code Breakdown</h1>
            <div>
                <strong>User Timing</strong>
                <p>This is the action we are performing before we complete our mark. You should be able to verify in your user
                    timing that this operation was performed</p>
                <pre>
                        <code class="javascript">
const name = timing.value;
performance.mark(`${name}_start`);
sampleIterateAdd();
setTimeout(() =>{
    performance.mark(`${name}_end`);
    performance.measure(name, `${name}_start`, `${name}_end`);
},timerInt);
                        </code>
                    </pre>
            </div>
            <div>
                <strong>Operation</strong>
                <p>This is the action we are performing before we complete our mark. You should be able to verify in your user
                    timing that this operation was performed</p>
                <pre>
                <code class="javascript">
const sampleIterateAdd = () => {
    for(let i=0; i < 100; i++) {
        console.log('Number is now', i);
    }
}
                </code>
            </pre>
            </div>
        </section>
    </article>
    <script src="example.js"></script>
</body>

</html>